import java.io.*;
import java.math.BigDecimal;
import java.nio.charset.StandardCharsets;
import java.nio.file.*;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.logging.Level;
import java.util.logging.Logger;

public class Main {
        private static final DateTimeFormatter TS_FMT = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        private static final Logger log = Logger.getLogger(Main.class.getName());
        private static class Config {
                String table = "meter_readings";
                int batchSize = 1000;
                boolean skipNonNumeric = false;
                boolean failNonNumeric = false;

                // Validation & input handling
                boolean strict = true;
                boolean unwrapPdf = false;
                char delimiter = ',';
                Path output;
                List<Path> inputs = new ArrayList<>();
        }
        private static class Row {
                final String nmi;
                final LocalDateTime ts;
                final BigDecimal consumption;
                Row(String nmi, LocalDateTime ts, BigDecimal consumption) {
                        this.nmi = nmi; this.ts = ts; this.consumption = consumption;
                }
        }
        public static void main(String[] args) {
                try {
                        Config cfg = parseArgs(args);
                        if (cfg == null) return;
                        if (cfg.output.getParent() != null) Files.createDirectories(cfg.output.getParent());
                        try (BufferedWriter out = Files.newBufferedWriter(cfg.output, StandardCharsets.UTF_8)) {
                                out.write("-- Generated by Main.java\n-- Target table: " + cfg.table + "\n\n");
                                List<Row> batch = new ArrayList<>(cfg.batchSize);
                                String currentNmi = null;
                                Integer currentIntervalMins = null;
                                for (Path input : cfg.inputs) {
                                        try (BufferedReader br = Files.newBufferedReader(input, StandardCharsets.UTF_8)) {
                                                String line;
                                                while ((line = br.readLine()) != null) {
                                                        if (line.isEmpty()) continue;
                                                        List<String> row = splitCsv(line, cfg.delimiter);
                                                        if (row.isEmpty()) continue;
                                                        String rec = row.get(0).trim();
                                                        switch (rec) {
                                                                case "100": break;
                                                                case "200":
                                                                        currentNmi = safeGet(row, 1);
                                                                        String mins = safeGet(row, 8);
                                                                        if (currentNmi == null || currentNmi.isEmpty())
                                                                                throw new RuntimeException("Missing NMI in 200 record: " + row);
                                                                        try { currentIntervalMins = Integer.parseInt(mins); }
                                                                        catch (Exception e) { throw new RuntimeException("Invalid interval minutes in 200 record: " + row, e); }
                                                                        if (currentIntervalMins <= 0 || 1440 % currentIntervalMins != 0)
                                                                                throw new RuntimeException("Bad interval minutes (must divide 1440): " + currentIntervalMins);
                                                                        break;
                                                                case "300": {
                                                                        if (currentNmi == null || currentIntervalMins == null)
                                                                                throw new RuntimeException("300 encountered before a valid 200 block");

                                                                        int slots = 1440 / currentIntervalMins;
                                                                        int need  = 2 + slots; // index 0: "300", index 1: yyyymmdd, then 'slots' values

                                                                        // If you didnâ€™t add --unwrap-pdf support, just keep: List<String> row300 = row;
                                                                        List<String> row300 = cfg.unwrapPdf
                                                                                ? unwrapPdfIfNeeded(line, br, cfg.delimiter, need)
                                                                                : splitCsv(line, cfg.delimiter);

                                                                        int available = Math.max(0, row300.size() - 2);
                                                                        if (cfg.strict && available < slots) {
                                                                                String dayProbe = row300.size() > 1 ? row300.get(1) : "?";
                                                                                throw new RuntimeException(
                                                                                        "Malformed 300 record for date " + dayProbe + ": expected " + slots +
                                                                                                " values, found " + available + ". " +
                                                                                                "If the source is PDF-copied, re-export CSV or use --unwrap-pdf."
                                                                                );
                                                                        }

                                                                        String yyyymmdd = safeGet(row300, 1);
                                                                        if (yyyymmdd == null || yyyymmdd.length() != 8)
                                                                                throw new RuntimeException("Invalid date in 300 record: " + row300);

                                                                        LocalDate day = LocalDate.of(
                                                                                Integer.parseInt(yyyymmdd.substring(0, 4)),
                                                                                Integer.parseInt(yyyymmdd.substring(4, 6)),
                                                                                Integer.parseInt(yyyymmdd.substring(6, 8))
                                                                        );

                                                                        for (int i = 0; i < slots; i++) {
                                                                                String cell = safeGet(row300, 2 + i);
                                                                                BigDecimal val;
                                                                                if (cell == null || cell.trim().isEmpty()) {
                                                                                        if (cfg.skipNonNumeric) continue;
                                                                                        val = BigDecimal.ZERO;
                                                                                } else {
                                                                                        try {
                                                                                                val = new BigDecimal(cell.trim());
                                                                                        } catch (NumberFormatException nfe) {
                                                                                                if (cfg.failNonNumeric)
                                                                                                        throw new RuntimeException("Non-numeric interval '" + cell + "' (date " + yyyymmdd + ", slot " + i + ")", nfe);
                                                                                                if (cfg.skipNonNumeric) continue;
                                                                                                val = BigDecimal.ZERO;
                                                                                        }
                                                                                }

                                                                                LocalDateTime ts = day.atStartOfDay().plusMinutes((long) i * currentIntervalMins);
                                                                                batch.add(new Row(currentNmi, ts, val));
                                                                                if (batch.size() >= cfg.batchSize) {
                                                                                        flushBatch(out, cfg.table, batch);
                                                                                        batch.clear();
                                                                                }
                                                                        }
                                                                        break;
                                                                }

                                                                case "500":
                                                                        currentNmi = null;
                                                                        currentIntervalMins = null;
                                                                        break;
                                                                case "900": break;
                                                                default: break;
                                                        }
                                                }
                                        }
                                }
                                if (!batch.isEmpty()) {
                                        flushBatch(out, cfg.table, batch);
                                        batch.clear();
                                }
                        }
                        log.info("Wrote SQL to " + cfg.output.toAbsolutePath());
                } catch (Exception e) {
                        log.log(Level.SEVERE, "[ERROR] " + e.getMessage(), e);
                        e.printStackTrace(System.err);
                        System.exit(1);
                }
        }
        private static void flushBatch(BufferedWriter out, String table, List<Row> batch) throws IOException {
                out.write("INSERT INTO " + table + " (\"nmi\",\"timestamp\",\"consumption\") VALUES\n");

                for (int i = 0; i < batch.size(); i++) {
                        Row r = batch.get(i);
                        String tsStr = TS_FMT.format(r.ts);
                        String nmiSql = r.nmi.replace("'", "''");

                        out.write("""
                ('%s', '%s', %s)%s
                """.formatted(
                                nmiSql,
                                tsStr,
                                r.consumption.toPlainString(),
                                (i == batch.size() - 1) ? "\n" : ",\n"
                        ));
                }

                out.write("""
            ON CONFLICT ("nmi","timestamp") DO UPDATE 
            SET "consumption" = EXCLUDED."consumption";
            
            """);
        }

        private static String safeGet(List<String> row, int idx) {
                return idx < row.size() ? row.get(idx) : null;
        }

        // NOTE: Original PDF sample had wrapped decimals (e.g., "1.\n271").
        //Input here was cleaned so each 300 record is single-line.
       //If PDF input had to be parsed directly, an unwrap merge step
       //would be needed before splitCsv()
        private static List<String> splitCsv(String line, char delimiter) {
                List<String> out = new ArrayList<>();
                StringBuilder cur = new StringBuilder();
                boolean inQuotes = false;
                for (int i = 0; i < line.length(); i++) {
                        char c = line.charAt(i);
                        if (inQuotes) {
                                if (c == '"') {
                                        if (i + 1 < line.length() && line.charAt(i + 1) == '"') {
                                                cur.append('"');
                                                i++;
                                        } else {
                                                inQuotes = false;
                                        }
                                } else {
                                        cur.append(c);
                                }
                        } else {
                                if (c == '"') inQuotes = true;
                                else if (c == delimiter) {
                                        out.add(cur.toString());
                                        cur.setLength(0);
                                } else {
                                        cur.append(c);
                                }
                        }
                }
                out.add(cur.toString());
                return out;
        }

        // --- Unwrap helper (used only when --unwrap-pdf is set) ---
        private static List<String> unwrapPdfIfNeeded(String firstLine, BufferedReader br, char delimiter, int need) throws IOException {
                StringBuilder merged = new StringBuilder(firstLine);
                List<String> row = splitCsv(merged.toString(), delimiter);
                if (row.size() >= need) return row;

                br.mark(1 << 16); // allow rollback (~64KB buffer)
                String next;
                while (row.size() < need && (next = br.readLine()) != null) {
                        if (next.isEmpty()) { br.mark(1 << 16); continue; }
                        String trimmed = next.trim();

                        // stop if next line looks like a new NEM12 record
                        if (trimmed.startsWith("100,") || trimmed.startsWith("200,") ||
                                trimmed.startsWith("300,") || trimmed.startsWith("500,") ||
                                trimmed.startsWith("900")) {
                                br.reset();
                                return row; // strict validation will handle missing values
                        }

                        // join lines like "1.\n271" -> "1.271"
                        merged.append(next);
                        row = splitCsv(merged.toString(), delimiter);
                        br.mark(1 << 16);
                }
                return row;
        }

        private static Config parseArgs(String[] args) {
                if (args.length == 0) { printHelp(); return null; }
                Config c = new Config();
                for (int i = 0; i < args.length; i++) {
                        String a = args[i];
                        switch (a) {
                                case "--table":
                                        requireArg(args, i, "--table");
                                        c.table = args[++i];
                                        break;
                                case "--batch":
                                        requireArg(args, i, "--batch");
                                        c.batchSize = Integer.parseInt(args[++i]);
                                        if (c.batchSize <= 0) throw new IllegalArgumentException("batch must be > 0");
                                        break;
                                case "--skip-nonnumeric":
                                        c.skipNonNumeric = true;
                                        break;
                                case "--fail-nonnumeric":
                                        c.failNonNumeric = true;
                                        break;
                                case "--delimiter":
                                        requireArg(args, i, "--delimiter");
                                        String d = args[++i];
                                        if (d.length() != 1) throw new IllegalArgumentException("delimiter must be a single character");
                                        c.delimiter = d.charAt(0);
                                        break;
                                case "-o":
                                        requireArg(args, i, "-o");
                                        c.output = Paths.get(args[++i]);
                                        break;
                                case "--unwrap-pdf":
                                        c.unwrapPdf = true;
                                        break;
                                case "--no-strict":
                                        c.strict = false;
                                        break;
                                default:
                                        if (a.startsWith("-")) {
                                                log.severe("Unknown option: " + a);
                                                printHelp();
                                                return null;
                                        } else {
                                                c.inputs.add(Paths.get(a));
                                        }
                        }
                }
                if (c.output == null) {
                        log.severe("Missing -o <output.sql>");
                        printHelp();
                        return null;
                }
                if (c.inputs.isEmpty()) {
                        log.severe("Provide at least one input file.");
                        printHelp();
                        return null;
                }
                return c;
        }
        private static void requireArg(String[] args, int i, String flag) {
                if (i + 1 >= args.length) throw new IllegalArgumentException("Missing value for " + flag);
        }
        private static void printHelp() {
                log.info(
                        "Usage: java Main [options] -o <output.sql> <input1.csv> [input2.csv ...]\n" +
                                "Options:\n" +
                                "  --table <name>           Target table (default: meter_readings)\n" +
                                "  --batch <n>              Rows per INSERT batch (default: 1000)\n" +
                                "  --skip-nonnumeric        Skip bad/blank interval cells (default: use 0)\n" +
                                "  --fail-nonnumeric        Abort on any non-numeric interval cell\n" +
                                "  --delimiter <char>       CSV delimiter (default: ,)\n" +
                                "  -o <path.sql>            Output SQL file (required)\n"
                );
        }
}
